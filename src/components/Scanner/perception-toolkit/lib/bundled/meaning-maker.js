/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

if(!self.perceptionToolkitLoader){const t=async t=>{if(!e[t]&&(await new Promise(async r=>{if("document"in self){const e=document.createElement("script");e.src=function(){let t="";return window.PerceptionToolkit&&window.PerceptionToolkit.config&&window.PerceptionToolkit.config.root&&(t=window.PerceptionToolkit.config.root),`${t}/lib/bundled`}()+t.slice(1),e.defer=!0,document.head.appendChild(e),e.onload=r}else importScripts(t),r()}),!e[t]))throw new Error(`Module ${t} didnâ€™t register its module`);return e[t]},r=async(r,e)=>{const o=await Promise.all(r.map(t));e(1===o.length?o[0]:o)},e={require:Promise.resolve(r)};self.perceptionToolkitLoader=((r,o,n)=>{e[r]||(e[r]=new Promise(async r=>{let e={};const a={uri:location.origin+function(){let t="";return window.PerceptionToolkit&&window.PerceptionToolkit.config&&window.PerceptionToolkit.config.root&&(t=window.PerceptionToolkit.config.root),`${t}/lib/bundled`}()+name.slice(1)},s=await Promise.all(o.map(r=>"exports"===r?e:"module"===r?a:t(r))),i=n(...s);e.default||(e.default=i),r(e)}))})}perceptionToolkitLoader("./meaning-maker.js",["exports"],function(t){"use strict";function r(t,r){return t+"__"+r}function e(t,r,e){return"flatMap"in Array.prototype?t.flatMap(r):function(t,r){return t.reduce((t,e,o,n)=>{const a=r(e,o,n);return Array.isArray(a)?t.concat(a):(t.push(a),t)},[])}(t,r)}class o{constructor(){this.artstores=[],this.nearbyMarkers=new Map,this.nearbyResults=new Set,this.currentGeolocation={}}async addArtifactStore(t){return this.artstores.push(t),this.generateDiffs()}async updateGeolocation(t){return this.currentGeolocation=t,this.generateDiffs()}async markerFound(t){return this.nearbyMarkers.set(r(t.type,t.value),t),this.generateDiffs()}async markerLost(t){return this.nearbyMarkers.delete(r(t.type,t.value)),this.generateDiffs()}async generateDiffs(){const t=new Set(e(this.artstores,t=>t.findRelevantArtifacts(Array.from(this.nearbyMarkers.values()),this.currentGeolocation))),r=[...t].filter(t=>!this.nearbyResults.has(t)),o=[...this.nearbyResults].filter(r=>!t.has(r)),n={found:[],lost:[]};for(const{target:t,artifact:e}of r){const r=e.arContent;n.found.push({target:t,content:r,artifact:e})}for(const{target:t,artifact:r}of o){const e=r.arContent;n.lost.push({target:t,content:e,artifact:r})}return this.nearbyResults=t,n}}class n{decode(t){return this.decodeUnknown(t)}decodeUnknown(t){if(Array.isArray(t))return this.decodeArray(t);if(!("@type"in t)||"string"!=typeof t["@type"])return[];switch(t["@type"]){case"DataFeed":return this.decodeDataFeed(t);case"ARArtifact":return this.decodeArArtifact(t);default:return[]}}decodeArray(t){return e(t,t=>this.decodeUnknown(t))}decodeDataFeed(t){const r=t.dataFeedElement;return r?Array.isArray(r)?this.decodeArray(r):this.decodeUnknown(r):[]}decodeArArtifact(t){return[t]}}class a{constructor(){this.decoder=new n}async fromHtmlUrl(t){const r=await fetch(t.toString()),e=await r.text(),o=(new DOMParser).parseFromString(e,"text/html");return this.fromElement(o,t)}async fromJsonUrl(t){const r=await fetch(t.toString());if(!r.ok)throw Error(r.statusText);const e=await r.json();return this.fromJson(e)}async fromElement(t,r){const e=[],o=t.querySelectorAll("script[type='application/ld+json']:not([src])");for(const t of o)e.push(this.fromJson(JSON.parse(t.textContent||"")));const n=t.querySelectorAll("script[type='application/ld+json'][src]");for(const t of n){const o=t.getAttribute("src");o&&e.push(this.fromJsonUrl(new URL(o,r)))}const a=t.querySelectorAll("link[rel='alternate'][type='application/ld+json'][href]");for(const t of a){const o=t.getAttribute("href");o&&e.push(this.fromJsonUrl(new URL(o,r)))}return s=await Promise.all(e),"flat"in Array.prototype?s.flat(i):function(t,r){const e=t=>t.reduce((t,r)=>t.concat(r),[]);let o=e(t);if(r)for(let t=1;t<r;t++)o=e(o);return o}(s);var s,i}async fromJson(t){return this.decoder.decode(t)}}class s{constructor(){this.markers=new Map}addMarker(t,r){r.text&&this.markers.set(r.text,{target:r,artifact:t})}findRelevantArtifacts(t){const r=[];for(const e of t){if(!e.value)continue;const t=this.markers.get(e.value);t&&r.push(t)}return r}}class i{constructor(){this.markerStore=new s}addArtifact(t){if(!t.arTarget)return;let r=[];r=Array.isArray(t.arTarget)?t.arTarget:[t.arTarget];for(const e of r){switch(e["@type"]||""){case"Barcode":this.markerStore.addMarker(t,e)}}}findRelevantArtifacts(t,r){return this.markerStore.findRelevantArtifacts(t)}}t.MeaningMaker=class{constructor(){this.artloader=new a,this.artstore=new i,this.artdealer=new o,this.artdealer.addArtifactStore(this.artstore)}async init(){const t=await this.artloader.fromElement(document,document.URL);this.saveArtifacts(t)}async loadArtifactsFromJsonldUrl(t){const r=await this.artloader.fromJsonUrl(t);this.saveArtifacts(r)}async loadArtifactsFromSameOriginUrl(t){if(t.hostname!==window.location.hostname||t.port!==window.location.port||t.protocol!==window.location.protocol)return;const r=await this.artloader.fromHtmlUrl(t);for(const t of r)this.artstore.addArtifact(t)}async markerFound(t){try{const r=new URL(t.value);await this.loadArtifactsFromSameOriginUrl(r)}catch(t){}return this.artdealer.markerFound(t)}async markerLost(t){return this.artdealer.markerLost(t)}async updateGeolocation(t){return this.artdealer.updateGeolocation(t)}saveArtifacts(t){for(const r of t)this.artstore.addArtifact(r)}},Object.defineProperty(t,"__esModule",{value:!0})});
