{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","components/Scanner/perception-toolkit/lib/src/utils/fire.js","components/Scanner/perception-toolkit/lib/src/support/device-support.js","components/Scanner/perception-toolkit/lib/src/support/get-user-media.js","components/Scanner/perception-toolkit/lib/src/support/wasm.js","components/Scanner/perception-toolkit/lib/src/elements/stream-capture/stream-capture.js","components/Scanner/perception-toolkit/lib/src/utils/logger.js","components/Scanner/perception-toolkit/lib/src/detectors/barcode.js","components/Scanner/perception-toolkit/lib/src/utils/clamp.js","components/Scanner/perception-toolkit/lib/perception-toolkit/events.js","components/Scanner/perception-toolkit/lib/src/utils/inject-script.js","components/Scanner/perception-toolkit/lib/src/utils/environment-camera.js","components/Scanner/perception-toolkit/lib/perception-toolkit/index.js"],"names":["_slicedToArray","arr","i","Array","isArray","_arrayWithHoles","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","_iterableToArrayLimit","TypeError","_nonIterableRest","fire","name","target","detail","evt","CustomEvent","bubbles","dispatchEvent","DeviceSupport","Object","classCallCheck","this","useEvents","detectors","Map","createClass","key","detector","supported","has","Error","concat","set","delete","_detect","asyncToGenerator","regenerator_default","a","mark","_callee","support","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_ref3","_ref2","wrap","_context","prev","sent","t0","return","finish","supportsEvent","self","abrupt","stop","apply","arguments","GetUserMediaSupport","_supported","navigator","mediaDevices","WasmSupport","DEBUG_LEVEL","frameEvent","closeEvent","StreamCapture","captureScale","captureRate","capturePng","flipped","paused","layoutRefs","window","PerceptionToolkit","console","log","container","root","lastCapture","stream","_this","initElementsIfNecessary","scale","min","Number","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","Math","clamp","video","update","now","ctx","drawImage","videoWidth","videoHeight","captureFrame","requestAnimationFrame","muted","srcObject","play","addEventListener","frameCount","redoCheck","canvas","Promise","resolve","width","height","translate","once","_captureFrame","_callee2","_this2","_context2","imgData","Image","src","toDataURL","onload","getImageData","tracks","getTracks","clearRect","document","getElementById","getContext","markerDetect","cameraAccessDenied","injectScript","reject","script","createElement","onerror","head","appendChild","msg","level","INFO","tag","DEBUG","label","labelStr","WARNING","ERROR","applyTagIfProvided","error","warn","detectBarcodes","_x","_detectBarcodes","data","_ref","_ref$context","context","_ref$forceNewDetector","forceNewDetector","_ref$polyfillRequired","polyfillRequired","_ref$polyfillPrefix","polyfillPrefix","_args","BarcodeDetector","isReady","detect","message","supportsEnvironmentCamera","_supportsEnvironmentCamera","devices","cameras","filter","t","kind","some","camera","capabilities","getCapabilities","facingMode","find","f","hintTimeout","config","deviceNotSupported","detectedMarkers","attemptDetection","ImageData","capture","isProcessingCapture","onConnectivityChanged","CapturedContent","Events","CameraAccessDenied","CaptureClosed","captureClosed","CaptureStopped","DeviceNotSupported","MarkerChanges","Functions","initializeExperience","closeExperience","callbackFunction","callback","call","deviceSupportTest","deviceSupport","addDetector","_config$detectionMode","detectionMode","defaultPrevented","alert","beginDetection","then","_callee3","_ref2$detectionMode","_context3","createStreamCapture","isFunction","func","toString","onMarkerFound","_callee4","barcodeContent","_context4","_callee7","streamOpts","hasEnvCamera","isRequestingNewStream","_context7","_callee5","_context5","getUserMedia","enumerateDevices","_callee6","_context6","parentNode","hidden","start","setTimeout","clearTimeout","_callee9","markers","marker","markerAlreadyDetected","_context9","rawValue","performance","_callee8","removals","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_ref8","_ref7","timeLastSeen","_context8","entries","all","connected","onLine"],"mappings":"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","file":"static/js/4.56200746.chunk.js","sourcesContent":["import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","/**\n * A convenience function for firing custom events.\n *\n * ```javascript\n * fire('eventname', someElement, {foo: 'bar'});\n * ```\n */\nexport function fire(name, target, detail) {\n    const evt = new CustomEvent(name, {bubbles: true, detail});\n    target.dispatchEvent(evt);\n    return evt;\n}\n\n\n","import {fire} from '../utils/fire.js';\n\nexport class DeviceSupport {\n    constructor() {\n        this.useEvents = false;\n        this.detectors = new Map();\n    }\n\n    addDetector(detector) {\n        const {name, supported} = detector;\n        if (this.detectors.has(name)) {\n            throw new Error(`${name} already added`);\n        }\n        this.detectors.set(name, supported);\n    }\n\n    removeDetector(name) {\n        this.detectors.delete(name);\n    }\n\n    async detect() {\n        const support = {};\n        for (const [name, detector] of this.detectors) {\n            support[name] = await detector();\n        }\n        if (this.useEvents) {\n            fire(DeviceSupport.supportsEvent, self, support);\n        }\n        return support;\n    }\n}\n\nDeviceSupport.supportsEvent = 'supports';\n\n","export const GetUserMediaSupport = {\n    name: 'getUserMedia',\n    supported: async () => {\n        return 'mediaDevices' in self.navigator &&\n            'getUserMedia' in self.navigator.mediaDevices;\n    }\n};\n\n","export const WasmSupport = {\n    name: 'wasm',\n    supported: async () => {\n        return 'WebAssembly' in self;\n    }\n};\n\n","import {clamp} from '../../utils/clamp.js';\nimport {fire} from '../../utils/fire.js';\n\nexport const captureStopped = 'pt.capturestopped';\n/**\n * The name for captured frame events.\n */\nexport const frameEvent = 'pt.captureframe';\n/**\n * The name for start capture events.\n */\nexport const startEvent = 'pt.capturestarted';\n/**\n * The name for stop capture events.\n */\nexport const stopEvent = 'pt.capturestopped';\n/**\n * The name for stop capture events.\n */\nexport const closeEvent = 'pt.captureclose';\n\nexport class StreamCapture {\n\n    constructor() {\n        /**\n         * The sample scale, intended to go between `0` and `1` (though clamped only\n         * to `0` in case you wish to sample at a larger scale).\n         */\n        this.captureScale = 0.5;\n        /**\n         * How often to capture the stream in ms, where `0` represents never.\n         * Note that you can cause performance issues if `captureRate` is higher than\n         * the speed at which the captured pixels can be processed.\n         */\n        this.captureRate = 0;\n        /**\n         * Whether to capture a PNG `HTMLImageElement` instead of `ImageData`\n         * (the default).\n         */\n        this.capturePng = false;\n        /**\n         * Whether to flip the stream's image.\n         */\n        this.flipped = false;\n        /**\n         * Whether to pause the frame.\n         */\n        this.paused = false;\n\n        const {layoutRefs} = window.PerceptionToolkit.StreamCapture;\n        console.log('layoutRefs', layoutRefs);\n\n        const {container} = layoutRefs;\n        this.root = container;\n        this.lastCapture = -1;\n\n        console.log('StreamCapture', this);\n    }\n\n    /**\n     * Starts the capture of the stream.\n     */\n    start(stream) {\n        console.log('startStream');\n\n        if (this.stream) {\n            throw new Error('Stream already provided. Stop the capture first.');\n        }\n        this.stream = stream;\n        this.initElementsIfNecessary();\n        const scale = clamp(this.captureScale, 0);\n        const video = this.video;\n        const update = (now) => {\n            if (!this.video || !this.ctx) {\n                return;\n            }\n            if (!this.paused) {\n                this.ctx.drawImage(this.video, 0, 0, this.video.videoWidth * scale, this.video.videoHeight * scale);\n            }\n            if (this.captureRate !== 0 && now - this.lastCapture > this.captureRate) {\n                this.lastCapture = now;\n                this.captureFrame();\n            }\n            requestAnimationFrame((now) => update(now));\n        };\n        video.muted = true;\n        video.srcObject = this.stream;\n        video.play();\n        video.addEventListener('playing', async () => {\n            if (!this.video || !this.canvas || !this.ctx) {\n                return;\n            }\n            // There appears to be some form of condition where video playback can\n            // commence without the video dimensions being populated in Chrome. As\n            // such we attempt to wait some frames first.\n            let frameCount = 5;\n            let redoCheck = true;\n            while (redoCheck) {\n                frameCount--;\n                await new Promise((resolve) => requestAnimationFrame(resolve));\n                redoCheck = frameCount > 0 &&\n                    (this.video.videoWidth === 0 || this.video.videoHeight === 0);\n            }\n            // Should we arrive here without video dimensions we throw.\n\n            if (this.video.videoWidth === 0 || this.video.videoHeight === 0) {\n                throw new Error('Video has width or height of 0');\n            }\n\n            this.canvas.width = this.video.videoWidth * this.captureScale;\n            this.canvas.height = this.video.videoHeight * this.captureScale;\n\n            // Flip the canvas if -- say -- the camera is pointing at the user.\n            if (this.flipped) {\n                this.ctx.translate(this.canvas.width * 0.5, 0);\n                this.ctx.scale(-1, 1);\n                this.ctx.translate(-this.canvas.width * 0.5, 0);\n            }\n            requestAnimationFrame((now) => {\n                update(now);\n                fire(startEvent, this.root);\n            });\n        }, {once: true});\n    }\n\n    /**\n     * Manually captures a frame. Intended to be used when `captureRate` is `0`.\n     */\n    async captureFrame() {\n        console.log('captureFrame', this);\n\n        if (!this.ctx || !this.canvas) {\n            throw new Error('Unable to capture frame');\n        }\n        return new Promise((resolve) => {\n            const canvas = this.canvas;\n            const ctx = this.ctx;\n            let imgData;\n            if (this.capturePng) {\n                imgData = new Image();\n                imgData.src = canvas.toDataURL('image/png');\n                imgData.onload = () => {\n                    if (this.captureRate !== 0) {\n                        fire(frameEvent, this.root, {imgData});\n                    }\n                    resolve(imgData);\n                };\n            } else {\n                imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                if (this.captureRate !== 0) {\n                    fire(frameEvent, this.root, {imgData});\n                }\n                resolve(imgData);\n            }\n        });\n    }\n\n    /**\n     * Stops the stream.\n     */\n    stop() {\n        console.log('stopStreamCapture', this);\n\n        if (!this.stream || !this.ctx || !this.canvas) {\n            return;\n        }\n        const tracks = this.stream.getTracks();\n        for (const track of tracks) {\n            track.stop();\n        }\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.video = undefined;\n        this.stream = undefined;\n        this.canvas = undefined;\n        this.ctx = undefined;\n        fire(stopEvent, this.root);\n    }\n\n    initElementsIfNecessary() {\n        console.log('initElementsIfNecessary', this.root);\n\n        this.canvas = document.getElementById('capture-canvas');\n        this.ctx = this.canvas.getContext('2d');\n\n        if (!this.ctx) {\n            throw new Error('Unable to create canvas context');\n        }\n\n        if (!this.video) {\n            this.video = document.getElementById('capture-video');\n        }\n    }\n}\n","/**\n * Represents the debug level for logging.\n */\nexport var DEBUG_LEVEL;\n(function (DEBUG_LEVEL) {\n    /**\n     * All messages.\n     */\n    DEBUG_LEVEL[DEBUG_LEVEL[\"VERBOSE\"] = 4] = \"VERBOSE\";\n    /**\n     * Info.\n     */\n    DEBUG_LEVEL[DEBUG_LEVEL[\"INFO\"] = 3] = \"INFO\";\n    /**\n     * Warnings.\n     */\n    DEBUG_LEVEL[DEBUG_LEVEL[\"WARNING\"] = 2] = \"WARNING\";\n    /**\n     * Errors.\n     */\n    DEBUG_LEVEL[DEBUG_LEVEL[\"ERROR\"] = 1] = \"ERROR\";\n    /**\n     * No messages.\n     */\n    DEBUG_LEVEL[DEBUG_LEVEL[\"NONE\"] = 0] = \"NONE\";\n})(DEBUG_LEVEL || (DEBUG_LEVEL = {}));\n\n/**\n * Enables logging at the given level. Note: by default debugging is disabled.\n */\nexport function enableLogLevel(level) {\n    self.DEBUG = level;\n}\n\n/**\n * Logs a message.\n *\n * ```javascript\n *\n * // Enable ERROR and WARNING messages.\n * enableLogLevel(DEBUG_LEVEL.WARNING);\n *\n * // Ignored.\n * log('Bar!', DEBUG_LEVEL.INFO);\n *\n * // A tagged message.\n * log('Foo!', DEBUG_LEVEL.WARNING, 'some tag');\n *\n * // A non-tagged message.\n * log('Baz!', DEBUG_LEVEL.ERROR)\n * ```\n */\nexport function log(msg, level = DEBUG_LEVEL.INFO, tag) {\n    if (typeof DEBUG === 'undefined' || level > DEBUG) {\n        return;\n    }\n    const label = applyTagIfProvided(level, tag);\n    switch (level) {\n        case DEBUG_LEVEL.ERROR:\n            console.error(label, msg);\n            break;\n        case DEBUG_LEVEL.WARNING:\n            console.warn(label, msg);\n            break;\n        default:\n            console.log(label, msg);\n            break;\n    }\n}\n\nfunction applyTagIfProvided(label, tag) {\n    let labelStr = '';\n    switch (label) {\n        case DEBUG_LEVEL.WARNING:\n            labelStr = 'WARNING';\n            break;\n        case DEBUG_LEVEL.ERROR:\n            labelStr = 'ERROR';\n            break;\n        default:\n            labelStr = 'INFO';\n            break;\n    }\n    if (!tag) {\n        return `${labelStr}:`;\n    }\n    return `${labelStr} [${tag}]:`;\n}\n\n\n","import {injectScript} from '../utils/inject-script.js';\nimport {DEBUG_LEVEL, log} from '../utils/logger.js';\n\nlet detector;\n\n/**\n * Detects barcodes from image sources.\n */\nexport async function detectBarcodes(data, {context = window, forceNewDetector = false, polyfillRequired = false, polyfillPrefix = ''} = {}) {\n    const loadPolyfill = polyfillRequired ||\n        (context === window && !('BarcodeDetector' in context));\n    if (loadPolyfill) {\n        log('Using barcode detection polyfill', DEBUG_LEVEL.INFO, 'BarcodeDetector');\n        await injectScript(`${polyfillPrefix}/lib/polyfills/barcode-detector.js`);\n    }\n\n    if (!detector || forceNewDetector) {\n        detector = new context.BarcodeDetector();\n    }\n\n    if ('isReady' in detector) {\n        await detector.isReady;\n    }\n    try {\n        return await detector.detect(data);\n    } catch (e) {\n        // If the polyfill has loaded but there are still issues, exit.\n        if (polyfillRequired) {\n            return [];\n        }\n        log(`Detection failed: ${e.message}`, DEBUG_LEVEL.WARNING);\n        return await detectBarcodes(data, {\n            context,\n            forceNewDetector,\n            polyfillPrefix,\n            polyfillRequired: true\n        });\n    }\n}\n\n\n","/**\n * Clamps a number between `min` and `max` values. Both `min` and `max` are\n * optional.\n *\n * ```javascript\n * clamp(100, 0, 40);  // 40.\n * ```\n */\nexport function clamp(value, min = Number.NEGATIVE_INFINITY, max = Number.POSITIVE_INFINITY) {\n    return Math.max(min, Math.min(max, value));\n}\n\n\n","export {captureStopped, closeEvent as captureClosed} from '../src/elements/stream-capture/stream-capture.js';\nexport const markerDetect = 'pt.markerdetect';\nexport const cameraAccessDenied = 'pt.cameraaccessdenied';\nexport const markerChanges = 'pt.markerchanges';\n\n","/**\n * A convenience function for injecting scripts into the document head. The\n * `Promise` will either `resolve` (successful load) or `reject` (script error).\n *\n * ```javascript\n * await injectScript('/path/to/some/javascript.js');\n * ```\n */\nexport function injectScript(src) {\n    return new Promise((resolve, reject) => {\n        const script = document.createElement('script');\n        script.src = src;\n        script.onload = resolve;\n        script.onerror = reject;\n        document.head.appendChild(script);\n    });\n}\n\n\n","/**\n * Detects whether the user's device supports an environment-facing camera.\n *\n * **Note: calling this function will provide the user with a camera access\n * permission prompt, assuming one has not already been issued (such as for\n * `getUserMedia`). As such this API is best deferred until camera access has\n * been granted by the user.**\n *\n * ```javascript\n * const devices = await navigator.mediaDevices.enumerateDevices();\n * const supportsEnvironmentCamera =\n *    await EnvironmentCamera.supportsEnvironmentCamera(devices);\n * ```\n */\nexport async function supportsEnvironmentCamera(devices) {\n    const cameras = devices.filter(t => t.kind === 'videoinput');\n    return cameras.some((camera) => {\n        if (!('getCapabilities' in camera)) {\n            return false;\n        }\n        const capabilities = camera.getCapabilities();\n        if (!capabilities.facingMode) {\n            return false;\n        }\n        return capabilities.facingMode.find((f) => 'environment');\n    });\n}\n\n\n","import {DeviceSupport} from '../src/support/device-support.js';\nimport {GetUserMediaSupport} from '../src/support/get-user-media.js';\nimport {WasmSupport} from '../src/support/wasm.js';\nimport {fire} from '../src/utils/fire.js';\nimport {cameraAccessDenied, captureClosed, captureStopped, markerChanges, markerDetect} from './events.js';\nimport {detectBarcodes} from '../src/detectors/barcode.js';\nimport {closeEvent, frameEvent, StreamCapture} from '../src/elements/stream-capture/stream-capture.js';\nimport {supportsEnvironmentCamera} from '../src/utils/environment-camera.js';\nimport {DEBUG_LEVEL, enableLogLevel, log} from '../src/utils/logger.js';\n\nconst {config} = window.PerceptionToolkit;\nconst deviceNotSupported = 'pt.devicenotsupported';\nconst detectedMarkers = new Map();\nconst polyfillPrefix = window.PerceptionToolkit.config.root || '';\nconst attemptDetection = detectBarcodes(new ImageData(1, 1), {polyfillPrefix});\nconst capture = new StreamCapture();\nlet isProcessingCapture = false;\nlet hintTimeout;\n\nconst {layoutRefs} = window.PerceptionToolkit.StreamCapture;\nconsole.log('layoutRefs', layoutRefs);\n\nconst {container} = layoutRefs;\n\nenableLogLevel(DEBUG_LEVEL.ERROR);\n\nwindow.addEventListener(frameEvent, onCaptureFrame);\nwindow.addEventListener('offline', onConnectivityChanged);\nwindow.addEventListener('online', onConnectivityChanged);\n\nwindow.PerceptionToolkit.config = window.PerceptionToolkit.config || {};\n\nwindow.PerceptionToolkit.CapturedContent = {\n    detail: null\n};\n\nwindow.PerceptionToolkit.Events = {\n    CameraAccessDenied: cameraAccessDenied,\n    CaptureClosed: captureClosed,\n    CaptureStopped: captureStopped,\n    DeviceNotSupported: deviceNotSupported,\n    MarkerChanges: markerChanges,\n};\n\nwindow.PerceptionToolkit.Functions = {\n    initializeExperience,\n    closeExperience() {\n        console.log('closeExperience')\n    },\n    callbackFunction: config.callback\n};\n\nif (window.PerceptionToolkit.config.onload) {\n    window.PerceptionToolkit.config.onload.call(null);\n}\n\n/**\n * Perform a device support test.\n */\nconst deviceSupportTest = new Promise(async (resolve) => {\n    console.log('deviceSupportTest', this);\n\n    // Detect the necessary support.\n    const deviceSupport = new DeviceSupport();\n    deviceSupport.addDetector(GetUserMediaSupport);\n    deviceSupport.addDetector(WasmSupport);\n    const support = await deviceSupport.detect();\n\n    console.log('support', support);\n\n    // If everything necessary is supported, inject the loader and show it if\n    // desired.\n    if (support[GetUserMediaSupport.name] && support[WasmSupport.name]) {\n        resolve(true);\n    } else {\n        resolve(false);\n    }\n});\n\n/**\n * Initialize the experience.\n */\nasync function initializeExperience() {\n    console.log('initializeExperience', this);\n\n    //Check result of device support test.\n    const supported = await deviceSupportTest;\n    console.log('supported', supported);\n\n    if (!supported) {\n        const deviceNotSupportedEvt = fire(deviceNotSupported, window);\n        if (!deviceNotSupportedEvt.defaultPrevented) {\n            alert('Sorry, this browser does not support the required features')\n        }\n        return;\n    }\n\n    const {detectionMode = 'passive'} = config;\n\n    // Now the experience has begun, update the closeExperience fn.\n    window.PerceptionToolkit.Functions.closeExperience = closeExperience;\n\n    // Start detection\n    beginDetection(detectionMode).then('beginDetection');\n}\n\n/**\n * Begin Detection\n */\nasync function beginDetection({detectionMode = 'passive'}) {\n    console.log('beginDetection', this);\n\n    try {\n        // Wait for the faked detection to resolve.\n        await attemptDetection;\n\n        // Create the stream.\n        await createStreamCapture(detectionMode);\n    } catch (e) {\n        log(e.message, DEBUG_LEVEL.ERROR, 'Begin detection');\n    }\n}\n\n/*\n* Check whether the variable is a function.\n* */\nconst isFunction = func => func && {}.toString.call(func) === '[object Function]';\n\n/*\nHandle Marker discovery\n*/\nasync function onMarkerFound(evt) {\n    // alert(\"WASM SCANNER\");\n    console.log('onMarkerFound', evt, this);\n\n    // Display barcodeContent to the user.\n    let barcodeContent = evt.detail;\n    console.log('barcodeContent', barcodeContent);\n\n    // Run the callback function.\n    let {callbackFunction} = window.PerceptionToolkit.Functions;\n    if (isFunction(callbackFunction)) {\n        callbackFunction(barcodeContent);\n    }\n\n    // Save barcode content so that the react component can access it.\n    window.PerceptionToolkit.CapturedContent.detail = barcodeContent;\n}\n\n/**\n * Creates the stream an initializes capture.\n */\nasync function createStreamCapture(detectionMode) {\n    console.log('createStreamCapture', this);\n\n    if (detectionMode === 'passive') {\n        capture.captureRate = 600;\n    } else {\n        console.log('Tap to capture');\n        capture.root.addEventListener('click', async () => {\n            capture.paused = true;\n            console.log('Processing...');\n            const imgData = await capture.captureFrame();\n            fire(frameEvent, capture, {imgData, detectionMode});\n        });\n    }\n\n    capture.root.captureScale = 0.8;\n    capture.root.addEventListener(closeEvent, closeExperience);\n    capture.root.addEventListener(markerDetect, onMarkerFound);\n\n    const streamOpts = {\n        video: {\n            facingMode: 'environment'\n        }\n    };\n\n    // Attempt to get access to the user's camera.\n    try {\n        let stream = await navigator.mediaDevices.getUserMedia(streamOpts);\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const hasEnvCamera = await supportsEnvironmentCamera(devices);\n        capture.flipped = !hasEnvCamera;\n        // Ensure the stream is stopped and started when the user changes tabs.\n        let isRequestingNewStream = false;\n        window.addEventListener('visibilitychange', async () => {\n            if (isRequestingNewStream || capture.parentNode === null) {\n                return;\n            }\n            if (document.hidden) {\n                capture.stop();\n            } else {\n                // Block multiple requests for a new stream.\n                isRequestingNewStream = true;\n                stream = await navigator.mediaDevices.getUserMedia(streamOpts);\n                isRequestingNewStream = false;\n                // Bail if the document is hidden again.\n                if (document.hidden) {\n                    return;\n                }\n                // Ensure the capture is definitely stopped before starting a new one.\n                capture.stop();\n                capture.start(stream);\n            }\n        });\n        capture.start(stream);\n        hintTimeout = setTimeout(() => {\n            console.log('Make sure the marker is inside the box.');\n        }, config.hintTimeout || 5000);\n    } catch (e) {\n        // User has denied or there are no cameras.\n        fire(cameraAccessDenied, window);\n    }\n}\n\nexport function closeExperience() {\n    console.log('closeExperience', this);\n    capture.stop();\n    clearTimeout(hintTimeout);\n}\n\n/**\n * Processes the image data captured by the StreamCapture class, and hands off\n * the image data to the detector for processing.\n *\n * @param evt The Custom Event containing the captured frame data.\n */\nasync function onCaptureFrame(evt) {\n    console.log('onCaptureFrame', this);\n\n    // Prevent overloading the capture process.\n    if (isProcessingCapture) {\n        return;\n    }\n    isProcessingCapture = true;\n    const capture = evt.target;\n    const {detail} = evt;\n    const {detectionMode, imgData} = detail;\n\n    console.log('imgData', imgData);\n\n    const markers = await detectBarcodes(imgData, {polyfillPrefix});\n\n    for (const marker of markers) {\n        const markerAlreadyDetected = detectedMarkers.has(marker.rawValue);\n        // Update the last time for this marker.\n        detectedMarkers.set(marker.rawValue, self.performance.now());\n        if (markerAlreadyDetected) {\n            continue;\n        }\n        // Only fire the event if the marker is freshly detected.\n        fire(markerDetect, capture, marker.rawValue);\n    }\n    if (markers.length > 0) {\n        // Hide the hint if it's shown. Cancel it if it's pending.\n        clearTimeout(hintTimeout);\n        console.log('Marker length > 0');\n    } else if (detectionMode && detectionMode === 'active') {\n        console.log('No markers found');\n    }\n    capture.paused = false;\n\n    // Provide a cool-off before allowing another detection. This aids the case\n    // where a recently-scanned markers are mistakenly re-scanned.\n    setTimeout(async () => {\n        const now = self.performance.now();\n        const removals = [];\n        for (const [value, timeLastSeen] of detectedMarkers.entries()) {\n            if (now - timeLastSeen < 1000) {\n                continue;\n            }\n            detectedMarkers.delete(value);\n        }\n        // Wait for all dealer removals to conclude.\n        await Promise.all(removals);\n        isProcessingCapture = false;\n    }, 1000);\n}\n\n/**\n * Handles connectivity change for the user.\n */\nfunction onConnectivityChanged() {\n    console.log('onConnectivityChanged', this);\n\n    const connected = navigator.onLine;\n    if (!container) {\n        return;\n    }\n    if (!connected) {\n        console.log('Currently offline. Please reconnect to the network.');\n    } else {\n        console.log('Already online.')\n    }\n}\n"],"sourceRoot":""}